# cgo
通过cgo，go程序能够调用C的代码，利用现有的C库和函数。

# 怎么用

```golang
package main

/*
#include <stdio.h>
#include <stdlib.h>
void Print(char* s); // 声明Print函数
*/
import "C"
import (
	"fmt"
	"unsafe"
)

// 导出Print方法
//export Print
func Print(s *C.char) {
	fmt.Println(C.GoString(s))
}

func main() {
	str := "Hello World"
	cstr := C.CString(str)
	defer C.free(unsafe.Pointer(cstr))

	C.Print(cstr)
}

```
以上为一个简单的示例，通过`import "C"`启用CGO，CGO会将上一行代码的注释快的内容视为C代码块，被称为序文。

在序文中，引入头文件、定义变量和函数、类型声明以及配置编译选项。

cgo作为C和go之间的桥梁，使用场景主要分为两种：
* go调用C程序
* C调用go程序

在上述的示例中简单展示了这两种场景。

# 原理
在启用CGO之后，执行go build时会执行一些额外的工作来构建代码。主要有以下的几个步骤：
1. cgo 工具就会被调用，在 C 转换 Go、Go 转换 C 的之间生成各种文件。
2. 系统的 C 编译器会被调用来处理包中所有的 C 文件。
3. 所有独立的编译单元会被组合到一个 .o 文件。
4. 生成的 .o 文件会在系统的连接器中对它的引用进行一次检查修复。

可以运行`go tool cgo`命令，来查看经过cgo预处理之后的源文件。
```bash
➜  cgo git:(main) ✗ go tool cgo cgo.go
➜  cgo git:(main) ✗ tree -l
.
├── _obj
│   ├── _cgo_.o           // C代码编译出的链接库
│   ├── _cgo_export.c     
│   ├── _cgo_export.h     // 导出到C语言的Go类型
│   ├── _cgo_flags        // C代码的编译和链接选项
│   ├── _cgo_gotypes.go   // 导出到Go语言的C类型
│   ├── _cgo_main.c       // C代码部分的main函数
│   ├── cgo.cgo1.go       // 经过“预处理”的Go代码
│   └── cgo.cgo2.c        // 经过“预处理”的C代码
├── cgo
└── cgo.go
```

cgo.cgo1.go
```golang
// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/elias/docs/note/code/golang/cgo/cgo.go:1:1
package main

/*
#include <stdio.h>
#include <stdlib.h>
void Print(char* s);
*/
import _ "unsafe"
import (
	"fmt"
	"unsafe"
)

//export Print
func Print(s * /*line :15:15*/_Ctype_char /*line :15:21*/) {
	fmt.Println(( /*line :16:14*/_Cfunc_GoString /*line :16:23*/)(s))
}

func main() {
	str := "Hello World"
	cstr := ( /*line :21:10*/_Cfunc_CString /*line :21:18*/)(str)
	defer func() func() { _cgo0 := /*line :22:15*/unsafe.Pointer(cstr); return func() { _cgoCheckPointer(_cgo0, nil); /*line :22:36*/_Cfunc_free(_cgo0); }}()()

	( /*line :24:2*/_Cfunc_Print /*line :24:8*/)(cstr)
}

```
可以看到，经过处理之后，C.Print被改写成了_Cfunc_Print，_Cfunc_Print的定义在_cgo_gotypes.go中。
```golang
// Code generated by cmd/cgo; DO NOT EDIT.

package main

import "unsafe"

import _ "runtime/cgo"

import "syscall"

var _ syscall.Errno
func _Cgo_ptr(ptr unsafe.Pointer) unsafe.Pointer { return ptr }

//go:linkname _Cgo_always_false runtime.cgoAlwaysFalse
var _Cgo_always_false bool
//go:linkname _Cgo_use runtime.cgoUse
func _Cgo_use(interface{})
type _Ctype__GoString_ string

type _Ctype_char int8

type _Ctype_intgo = _Ctype_ptrdiff_t

type _Ctype_long int64

type _Ctype_ptrdiff_t = _Ctype_long

//go:notinheap
type _Ctype_void_notinheap struct{}

type _Ctype_void [0]byte

//go:linkname _cgo_runtime_cgocall runtime.cgocall
func _cgo_runtime_cgocall(unsafe.Pointer, uintptr) int32

//go:linkname _cgoCheckPointer runtime.cgoCheckPointer
func _cgoCheckPointer(interface{}, interface{})

//go:linkname _cgoCheckResult runtime.cgoCheckResult
func _cgoCheckResult(interface{})


// CString converts the Go string s to a C string.
//
// The C string is allocated in the C heap using malloc.
// It is the caller's responsibility to arrange for it to be
// freed, such as by calling C.free (be sure to include stdlib.h
// if C.free is needed).
func _Cfunc_CString(s string) *_Ctype_char {
	if len(s)+1 <= 0 {
		panic("string too large")
	}
	p := _cgo_cmalloc(uint64(len(s)+1))
	sliceHeader := struct {
		p   unsafe.Pointer
		len int
		cap int
	}{p, len(s)+1, len(s)+1}
	b := *(*[]byte)(unsafe.Pointer(&sliceHeader))
	copy(b, s)
	b[len(s)] = 0
	return (*_Ctype_char)(p)
}

//go:linkname _cgo_runtime_gostring runtime.gostring
func _cgo_runtime_gostring(*_Ctype_char) string

// GoString converts the C string p into a Go string.
func _Cfunc_GoString(p *_Ctype_char) string {
	return _cgo_runtime_gostring(p)
}
//go:cgo_import_static _cgo_a9330766d1f8_Cfunc_Print
//go:linkname __cgofn__cgo_a9330766d1f8_Cfunc_Print _cgo_a9330766d1f8_Cfunc_Print
var __cgofn__cgo_a9330766d1f8_Cfunc_Print byte
var _cgo_a9330766d1f8_Cfunc_Print = unsafe.Pointer(&__cgofn__cgo_a9330766d1f8_Cfunc_Print)

//go:cgo_unsafe_args
func _Cfunc_Print(p0 *_Ctype_char) (r1 _Ctype_void) {
	// 调用C方法
	_cgo_runtime_cgocall(_cgo_a9330766d1f8_Cfunc_Print, uintptr(unsafe.Pointer(&p0)))
	if _Cgo_always_false {
		_Cgo_use(p0) // 针对编译器的优化操作，为了将C函数的参数分配在堆上，实际永远不会执行
	}
	return
}
//go:cgo_import_static _cgo_a9330766d1f8_Cfunc_free
//go:linkname __cgofn__cgo_a9330766d1f8_Cfunc_free _cgo_a9330766d1f8_Cfunc_free
var __cgofn__cgo_a9330766d1f8_Cfunc_free byte
var _cgo_a9330766d1f8_Cfunc_free = unsafe.Pointer(&__cgofn__cgo_a9330766d1f8_Cfunc_free)

//go:cgo_unsafe_args
func _Cfunc_free(p0 unsafe.Pointer) (r1 _Ctype_void) {
	_cgo_runtime_cgocall(_cgo_a9330766d1f8_Cfunc_free, uintptr(unsafe.Pointer(&p0)))
	if _Cgo_always_false {
		_Cgo_use(p0)
	}
	return
}
//go:cgo_export_dynamic Print
//go:linkname _cgoexp_a9330766d1f8_Print _cgoexp_a9330766d1f8_Print
//go:cgo_export_static _cgoexp_a9330766d1f8_Print
func _cgoexp_a9330766d1f8_Print(a *struct {
		p0 *_Ctype_char
	}) {
	Print(a.p0)
}

//go:cgo_import_static _cgo_a9330766d1f8_Cfunc__Cmalloc
//go:linkname __cgofn__cgo_a9330766d1f8_Cfunc__Cmalloc _cgo_a9330766d1f8_Cfunc__Cmalloc
var __cgofn__cgo_a9330766d1f8_Cfunc__Cmalloc byte
var _cgo_a9330766d1f8_Cfunc__Cmalloc = unsafe.Pointer(&__cgofn__cgo_a9330766d1f8_Cfunc__Cmalloc)

//go:linkname runtime_throw runtime.throw
func runtime_throw(string)

//go:cgo_unsafe_args
func _cgo_cmalloc(p0 uint64) (r1 unsafe.Pointer) {
	_cgo_runtime_cgocall(_cgo_a9330766d1f8_Cfunc__Cmalloc, uintptr(unsafe.Pointer(&p0)))
	if r1 == nil {
		runtime_throw("runtime: C malloc failed")
	}
	return
}

```

调用流程
_Cfunc_Print ->
_cgo_runtime_cgocall(_cgo_a9330766d1f8_Cfunc_Print, uintptr(unsafe.Pointer(&p0))) ->
_cgo_a9330766d1f8_Cfunc_Print ->
Print(_cgo_a->p0) ->
crosscall2(_cgoexp_a9330766d1f8_Print, &_cgo_a, 8, _cgo_ctxt) ->
Go.Print

# CGO内存模型


# 有什么需要注意的

